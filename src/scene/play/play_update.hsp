#deffunc on_update_play
	// 再生タイミング関係の処理を実行
	processPlayTiming

	// 一時停止・早送りのキー入力を処理
	processPlaybackControlInput

	// 現在のカウント値(cnow)を計算
	calculateCurrentTick

	// 譜面停止中か判定
	stat1=0
	repeat max(stpnum-stpfcnt,0),stpfcnt
		if(cnow>=stp.cnt.0+stp.cnt.1):stpfcnt=cnt:continue
		if(cnow<stp.cnt.0):break
		if((cnow<stp.cnt.0+stp.cnt.1)&(cnow>=stp.cnt.0)){
			stat1=1
		}
	loop

	if((mstop=0)&(mshift=0)&(stat1=0)){
		if(cnt<12){
			ttp_=(ttp_+double(t_tp))/2
		}else:if(cnt<24){
			ttp_=(ttp_*3+double(t_tp))/4
		}else{
			ttp_=(ttp_*7+double(t_tp))/8
		}
		ttp=0
	}
	laserdelay0=laserdelay0_orig
	if(ts>120):ts=0
	if(ts2>60):ts2=0
	if(ts3>30):ts3=0
	ts_timer=d3timer()
	if(cnt=0):ts_timerp=ts_timer
	ts+=max(ts_timer-ts_timerp,1)
	ts2+=max(ts_timer-ts_timerp,1)
	ts3+=max(ts_timer-ts_timerp,1)
	ts_bass+=max(ts_timer-ts_timerp,1)
	ts_timerp=ts_timer
	cstp=0
	if(hsc=-1){
		cnowstpsh=getstpsh(cnow)
	}
	if(ginfo2()=0){
		getkey shift_key,16
		getkey ctrl_key,17
		getkey alt_key,18
		getkey_a stat2,39
		if((ctrl_key+stat2+alt_key+shift_key=4)&(ts>120)&(ginfo2()=0)){
			sync+=1.0
		}else:if((ctrl_key+stat2+alt_key=3)&(ts>120)&(ginfo2()=0)){
			sync+=5.0
		}
		getkey stat2,37
		if((ctrl_key+stat2+alt_key+shift_key=4)&(ts>120)&(ginfo2()=0)){
			sync-=1.0
		}else:if((ctrl_key+stat2+alt_key=3)&(ts>120)&(ginfo2()=0)){
			sync-=5.0
		}
	}
	if((t_moex<=rt)&(mfl=0)&(output=0)&(mendt=-1)&(mplayfl=1)){
		if((csongfile_empty=0)&(csongfile_exist=1)){
			if(rt>t_moex){
				foreach mid
					BASS_ChannelSetPosition_ms mid.cnt,rt-t_moex
				loop
				repeat swaudionum
					BASS_ChannelSetPosition_ms mid_sw.cnt,rt-t_moex
				loop
			}else{
				foreach mid
					BASS_ChannelSetPosition_ms mid.cnt,0
				loop
				repeat swaudionum
					BASS_ChannelSetPosition_ms mid_sw.cnt,0
				loop
			}
			foreach mid
				BASS_ChannelSetAttribute mid.cnt,2,0.0
			loop
			repeat swaudionum
				BASS_ChannelSetAttribute mid_sw.cnt,2,0.0
			loop
			foreach mid
				BASS_ChannelPlay mid.cnt
				if(mlinkfailed=0):break
			loop
			if(mlinkfailed!=0){
				repeat swaudionum
					BASS_ChannelPlay mid_sw.cnt
				loop
			}
			if(length(mid)=2){
				foreach mid
					BASS_ChannelUpdate mid.cnt
				loop
			}
			t_mo=t_moex
			mfl=1
		}
	}
	if(cnt=0):cnowstart=cnow
	if((-voffset-T_MOEX_DELAY-globaloffset<=t)&(vfl=0)&(vmov>=1)){
		if((cmovfile!="")&(output=0)){
			stat1=-voffset-T_MOEX_DELAY-globaloffset
			if(vmov=1){
				if(t>stat1):mci "seek v to "+(t-stat1)
				mci "play v"
			}
			if(t<=stat1){
				t_vo=t
			}else:t_vo=stat1
			vfl=1
		}
	}
	vflp=vfl
	mflp=mfl

	// GameSystemを更新
	UpdateGameSystem game_system, double(t)

	// 判定対象ノーツの情報の初期化
	dim arstat,8,3
	dim arfl,6
	repeat 6
		arstat.cnt.2=-1
	loop
	if(cnt=0){
		repeat 6
			arstatp.cnt.2=-1
		loop
	}
	stat4=0
	stat5=0

	// 判定対象のノーツを特定する
	// (arstatに書き込まれる)
	specifyJudgmentTargetOfButtonNotes
	specifyJudgmentTargetOfLaserNotes

	// 初回フレームは前フレームの判定対象ノーツの情報が存在しないので、
	// 現在フレームのもので上書き
	if(cnt=0){
		repeat 8
			cnt2=cnt
			repeat 3
				arstatp.cnt2.cnt=arstat.cnt2.cnt
			loop
		loop
		repeat 2
			arstatp.(6+cnt).0=0
		loop
	}

	// アナログデバイスの回すべき方向を決定
	anastraight=0,0
	repeat 2
		stat1=arstatp.(6+cnt).1
		if(arstat.(6+cnt).0=0){
			anadirection.cnt=1-cnt
		}else:if(analog.stat1.3<analog.stat1.4){
			anadirection.cnt=1
		}else:if(analog.stat1.3>analog.stat1.4){
			anadirection.cnt=0
		}else{
			if(analog.stat1.3=0){
				anadirection.cnt=1
			}
			if(analog.stat1.3=50){
				anadirection.cnt=0
			}
			anastraight.cnt=1
		}
	loop
	if(bpm!=bpmp):minforefresh=1

	// Escキーの入力を処理
	processEscKeyInput
	if (stat = 1) {
		// 押された場合はシーンを抜ける
		return 0
	}

	// キー入力を処理
	processKeyInput

	// BT/FXのノーツ判定処理
	processButtonNoteJudgment

	// LASERノーツ関連の値(現在位置や傾きなど)を準備
	prepareLaserRelatedValues

	// LASERノーツの判定を処理
	processLaserNoteJudgment

	// ハイスピ設定の変更を処理
	processHiSpeedChangeInput

	// ずれがある場合は補正
	fixPlaybackDelay

	// 直角音の再生
	processLaserSlamSound

	// キー音の再生
	processKeySound

	// ロングFX/LASERの音声エフェクト適用
	processAudioEffects

	// 音声バッファの更新
	foreach mid
		BASS_ChannelUpdate mid.cnt
	loop
	repeat swaudionum
		BASS_ChannelUpdate mid_sw.cnt
	loop

	// 次フレーム用に値を保管
	peffstatap=peffstata.0,peffstata.1
	canagainp=canagain
	filtertypep=filtertype
	filtertype2p=filtertype2

	// 画面回転の計算
	processLaneSpin	

	// スコア計算
	calculateTotalScore

	// 表示用スコアの計算(推移時間を設ける)
	calculateDisplayedTotalScore

	// フレームの描画処理を実行
	if(cnt\(frameskip+1)=0){
		drawFrame
	}

	// 時間待ち
	gsel 0
	if(output=0){
		if(vsync=1){
			if(cnt=0):d3d9vsync_init 60,0
			d3d9vsync 0
		}
		hgsync 0
	}else{
		hgsync 0
	}

	// 曲がループ再生されてしまう場合があるので2ループ目は消音する
	if(mrepeat=1){
		foreach mid
			BASS_ChannelSetAttribute mid.cnt,2,0.0
		loop
		repeat swaudionum
			BASS_ChannelSetAttribute mid_sw.cnt,2,0.0
		loop
	}

	// 次フレーム用にキー状態を保管
	foreach keystat
		cntkey=cnt
		repeat 11
			keystatp.cntkey.cnt=keystat.cntkey.cnt
		loop
	loop
	repeat 11
		keystatorp.cnt=keystator.cnt
	loop

	c2tcnt=0
	hsrccnt=0
	notecnt=0
	analogcnt=0
	rop=ro.0,ro.1
	rorp=ror
	tiltrnowp=tiltrnow
	tiltnowp=tiltnow
	tp=t
	tp2=tstat
	t_mop=t_mo
	rtp=rt
	atp=at
	bpmp=bpm
	bpmfxp=bpmfx
	repeat 8
		cnt2=cnt
		repeat 3
			arstatp.cnt2.cnt=arstat.cnt2.cnt
		loop
	loop
	bgnowp=bgnow
	ljudgep=ljudge.0,ljudge.1
	shljudgep=shljudge.0,shljudge.1,shljudge.2,shljudge.3
	anadirectionp=anadirection.0,anadirection.1
	analogposp=analogpos.0,analogpos.1
	analognowp=analognow.0,analognow.1
	panalognowp=panalognow.0,panalognow.1
	canalognowp=canalognow.0,canalognow.1
	ztopnowp=ztopnow
	zbotnowp=zbotnow
	zsidenowp=zsidenow
	ztiltnowp=ztiltnow
	ztiltratep=ztiltrate
	cnowp=cnow
	cnowfxp=cnowfx

	// IMEの無効化
	if(output=0){
		if((disableime>=1)&(((ts>160)&(disableime=2))|((cnt\2=0)&(disableime=3))|(disableime=3))){
			if(imeget()=1):imeset 0
		}
	}

	// PowerMate(連打式)でのキー入力割り込みの有効化
	// (割り込みイベントはkshootmania.hspに実装)
	if(analoginput=1){
		keshucnt=0:onkey 1
	}

	// 連番PNG出力での画像保存
	if(output!=0){
		saveFrameImage
	}

	return 1