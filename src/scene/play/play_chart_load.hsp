// これらの関数はグローバル変数を使用しているため注意
// (もともと一続きだったプログラムを単純に命令に分割しただけ)

#deffunc initChartVariables
	sdim csongfile,1,1
	cmovfile=""
	dim judge,6,2
	dim ljudge,2
	dim shljudge,4
	dim ljudgep,2
	dim shljudgep,4
	dim ljudgeendt,2
	dim shljudgeendt,4
	ljudgeendt=-50000,-50000
	shljudgeendt=-50000,-50000,-50000,-50000
	dim judgel,6,judgelmax,2
	dim judgelnext,6
	notenum=0
	notesejnum=0
	notefxnum=0
	shljnum=0
	longjnum=0
	analogjnum=0
	analoganjnum=0
	chiprate=1
	longrate=1
	laserrate=1
	dim note,131072,8
	dim notefx,131072,8
	dim notese,131072
	dim notesej,131072,4
	dim longj,131072,8
	dim shlj,131072,8
	dim analogj,131072,5
	dim analoganj,131072,6
	dim analoganjdamage,131072
	dim analogbuf,131072
	dim analogturn,2,131072
	dim analogturnnum,2
	dim noteresult,131072
	dim keystat,7,11
	dim keystatp,7,11
	dim keystator,11
	dim keystatorp,11
	dim longstat,2
	dim longcritical,2
	dim longstatpp,2
	dim lstartt,2
	dim shlstat,4
	dim shlcritical,4
	dim shlstatpp,4
	dim shlstartt,4
	analognum=0
	dim analog,131072,10
	dim analoggr,131072
	dim analoggrmax,2
	anarannum=0
	anaranfl=1
	dim anaran,131072,3
	dim anagrran,2,131072
	dim analognext,131072
	dim analogprev,131072
	fxparamsnum=0
	dim fxparams,131072,3
	fxnum=0
	dim fx,131072,5
	spinnum=0
	sprnum=0
	dim spin,131072,5
	dim spr,131072,6
	/*
	rotatenum=0
	dim rotate,131072,6*/
	tiltnum=0
	dim tilt,131072,2
	tilttype=0
	tiltstart=0
	tiltfcnt=-1
	bpmlnum=0
	dim bpml,131072,3
	beatlnum=0
	dim beatl,131072,2
	stpnum=0
	dim stp,131072,2
	anagainnum=0
	dim anagain,131072,3
	anafilnum=0
	dim anafil,131072,3
	anvolnum=0
	dim anvol,131072,3
	ansenum=0
	dim anse,131072,2
	ddim rop,2
	userfxnum=0
	sdim userfx_name,16,256
	ddim userfx_params,256,9
	ddim userfx_params_enable,256,9
	userfilternum=0
	sdim userfilter_name,16,256
	ddim userfilter_params,256,9
	ddim userfilter_params_min,256,9
	ddim userfilter_params_max,256,9
	userchprmnum=0
	userchprmfcnt=0
	ddim userchprm,4096,6
	sdim swaudio,256,32
	swaudionum=0
	dim userfx_swaudiomid,256
	spintp=0
	spinangle=0
	spinanglepp=0
	spinrpt=-50000
	spinrp=0
	spinrps=0
	dim spinnow,4
	spinnow=-1,0,0,-1 // 方向(L:0 R:1),開始c,長さc,番号
	dim sprnow,4
	sprnow=-1,0,0,-1 // 方向(L:0 R:1),開始c,長さc,番号
	bgmouikkaic=0
	bgmouikkaia=0
	bgmouikkai=0
	bgmouikkaicnt=-1
	bgmouikkaikaisu=2
	dim meshstat_y,2,2
	dim meshstat_x,2,2
	dim meshstat_z,2,2
	dim analogstatp,2
	dim arstatp,8,3
	dim analogpos,2
	analogpos=0,1000
	dim analognow,2
	analognow=-1,-1
	dim panalognow,2
	dim panalognow2,2
	panalognow=0,1000
	dim canalognow,2
	canalognow=-1,-1
	ddim anadamage,2
	shuwat=-50000
	ddim shuwapos,1
	shuwapos=1000.0f
	disableshuwa=0
	dim analogfuture,2
	analogfuture=-1,-1
	dim analognowp,2
	analognowp=-1,-1
	dim panalognowp,2
	panalognowp=0,0
	dim canalognowp,2
	canalognowp=0,0
	dim analogposp,2
	analogposp=0,1000
	dim analogokt,2
	analogokt=-50000,-50000
	dim analogngt,2
	analogngt=-50000,-50000
	dim analogngcnt,2
	analogngcnt=0,0
	dim anapret,2
	anapret=-50000,-50000
	dim anastartt,2
	anastartt=-50000,-50000
	dim anaendt,2
	anaendt=-50000,-50000
	dim anadjp,2
	anadjp=0,0
	dim analogokcnt,2
	analogokcnt=-1,-1
	dim analoganokt,2
	analoganokt=-50000,-50000
	dim analoganokcnt,2
	analoganokcnt=-1,-1
	dim analogefft,2,131072,2
	dim analogefftnum,2
	dim anaendstat,2
	anaendstat=-1,-1
	dim anadirection,2
	anadirection=1,0
	dim anadirectionp,2
	anadirectionp=1,0
	dim anaturnt,2
	anaturnt=-50000,-50000
	dim pdoutt,2
	pdoutt=-50000,-50000
	dim anakp,2
	anakp=-1,-1
	dim anakdiff,2
	anakdiff=0,0
	dim anaktp
	anaktp=0,0
	oldpfilter=0
	shaket=-50000
	shakewidth=0
	shake2c=-50000
	shake2width=0
	shake2len=1
	shake2n=1
	shake2type=1
	stat179p=1
	tadj=0
	stat0tp=0
	nowsttp=-1
	lanesubflp=1
	lanesubfl=0
	bpmlsttpfcnt=0
	bpmlsttpfcnt2=0
	bpmlcfcnt=0
	bpmlcfcnt_fx=0
	bpmlcfcnt_fx_50ms=0
	stpfcnt=0
	ddim ztopnowp,1
	ddim zbotnowp,1
	ddim zsidenowp,1
	ddim ztiltnowp,1
	ddim ztiltrate,1
	ddim ztiltratep,1
	ddim rorp,1
	ztilton=0
	csongtotal=0

	cnt2a=-1
	stat4=0
	cnt3=-1
	ddim cbcnt,1
	beatn=4
	beatd=4
	csongtitle=""
	csongtitleimg=""
	csongartist=""
	csongartistimg=""
	csongeffect=""      // IR用
	csongillustrator="" // IR用
	csongjacket=""
	csongvol=100*dirvol/100
	csongoftbpm=0
	laserdelay1=40
	disableautoanvol=0
	bgname="desert"
	bgname_l="arrow"
	bgspeed=0
	bgrotation=3
	csonglevel=0
	csongver=""
	csongver_int=100
	fxdefbuf_fx=""
	fxdefbuf_filter=""
	csongfile_exist=0
	csonginfo=""
	csongeffect=""
	csonglayerstr=""
	tiltp=7
	return

#deffunc loadKSHChartFile
	notesel buf
	noteload cnotesfile,-1

	// IR用に生のファイルハッシュ(BOM除去前)を計算
	varmd5 csongmd5hash, buf, strlen(buf)

	// BOMがあればUTF-8と判定し、BOMを除去
	isutf8=0
	if (lpeek(buf, 0) & 0x00FFFFFF) == 0xBFBBEF{
		isutf8=1
		DeleteUTF8BOM buf
	}

	// 譜面ファイルの内容を1行ずつ配列dに入れる
	sdim d,256,notemax
	repeat notemax
		noteget buf2,cnt
		d.cnt=buf2
	loop

	// 各小節ごとの譜面行の行数(分解能)を調べる
	dim div,8192
	divnum=0
	repeat length(d)
		cnt2=cnt
		if(d.cnt="--"){
			div.divnum=0
			exc=0
			repeat
				if(cnt2+cnt+1>=length(d)){
					break
				}
				if(d.(cnt2+cnt+1)="--"){
					break
				}
				if(strmid(d.(cnt2+cnt+1),7,1)!="|"){
					div.divnum--
				}
				div.divnum++
			loop
			divnum++
		}
	loop

	// IR用に正規化後のファイルハッシュを計算
	csongmd5hash_ir_chart = getChartIRHash(buf)

	// バッファを初期化(メモリを食うので)
	buf=""

	return

#deffunc parseKSHChartParamLines
	repeat length(d)
		cnt2a++
		if(d.cnt="--"){
			cnt3++ // カレント小節数
			if(cnt3>0):cbcnt+=UNIT_MEASURE*beatn/beatd
			cnt2=-1
			continue
		}
		if(StartsWith(d.cnt, "bg=")){
			bgname=strmid(d.cnt,3,128)
			_sjis_ bgname
			continue
		}
		if(StartsWith(d.cnt, "layer=")){
			csonglayerstr=strmid(d.cnt,6,256)
			_sjis_ csonglayerstr
			continue
		}
		if(StartsWith(d.cnt, "title=")){
			csongtitle=strmid(d.cnt,6,128)
			_utf8_ csongtitle
			if(vfoldername=1){
				csongtitle+="("+utf8enc(strmid(csongdir,instr(csongdir,0,"\\")+1,strlen(csongdir)-instr(csongdir,0,"\\")-1))+")"
			}
			continue
		}
		if(StartsWith(d.cnt, "title_img=")){
			csongtitleimg=strmid(d.cnt,10,128)
			_sjis_ csongtitleimg
			continue
		}
		if(StartsWith(d.cnt, "artist=")){
			csongartist=strmid(d.cnt,7,128)
			_utf8_ csongartist
			continue
		}
		if(StartsWith(d.cnt, "effect=")){
			csongeffect=strmid(d.cnt,7,128)
			_sjis_ csongeffect
			continue
		}
		if(StartsWith(d.cnt, "illustrator=")){
			csongillustrator=strmid(d.cnt,12,128)
			_sjis_ csongillustrator
			continue
		}
		if(StartsWith(d.cnt, "information=")){
			csonginfo=strmid(d.cnt,12,128)
			_sjis_ csonginfo
			continue
		}
		if(StartsWith(d.cnt, "artist_img=")){
			csongartistimg=strmid(d.cnt,11,128)
			_sjis_ csongartistimg
			continue
		}
		if(StartsWith(d.cnt, "jacket=")){
			csongjacket=strmid(d.cnt,7,128)
			_sjis_ csongjacket
			if(instr(csongjacket,0,".")=-1){
				if(iscmdline=0){
					if(instr(csongdir,instr(csongdir,0,"\\")+1,"\\")>=0){
						csongjacket="..\\..\\..\\..\\imgs\\jacket\\"+csongjacket+".jpg"
					}else:csongjacket="..\\..\\..\\imgs\\jacket\\"+csongjacket+".jpg"
				}
			}
		}
		if(StartsWith(d.cnt, "difficulty=")){
			stat2=strmid(d.cnt,11,16)
			if(stat2="light"){
				csongdifficulty=0
			}else:if(stat2="challenge"){
				csongdifficulty=1
			}else:if(stat2="extended"){
				csongdifficulty=2
			}else:csongdifficulty=3
			continue
		}
		if(StartsWith(d.cnt, "level=")){
			csonglevel=int(strmid(d.cnt,6,2))
			continue
		}
		if(StartsWith(d.cnt, "chokkakuautovol=")){
			disableautoanvol=1-max(min(int(strmid(d.cnt,16,1)),1),0)
		}
		if(StartsWith(d.cnt, "m=")){
			//BASS_SetConfig 45,16777216
			sdim csongfile,1,1
			stat1=strmid(d.cnt,2,1024)
			_sjis_ stat1
			split stat1,";",csongfile
			dim mid,length(csongfile)*(auto=0)+auto
			//dim mid_pre,length(csongfile)*(auto=0)+auto
			exist csongfile.0
			if((length(csongfile)=2)&(strsize=-1)):csongfile.0=csongfile.1
			if(length(csongfile)<=1){
				dim mid,1
				//dim mid_pre,1
				dim hPeakFX,1
				dim hPeakFX2,1
				dim hCompFX,1
				dim hVolFX2,1
				dim hBitCFX,1
				peffect=1
				feffect=1
			}else:if(length(csongfile)<=2){
				dim mid,2-(auto=1)
				//dim mid_pre,2-(auto=1)
				dim hPeakFX,2-(auto=1)
				dim hPeakFX2,2-(auto=1)
				dim hCompFX,2-(auto=1)
				dim hVolFX2,2-(auto=1)
				dim hBitCFX,2-(auto=1)
				peffect=1
				feffect=0
			}else{
				peffect=0
				feffect=0
			}
			exist csongfile.(max(length(csongfile)-1,0))
			if((auto=1)&(length(csongfile)>=4)&(strsize!=-1)){
				csongfile.0=csongfile.1
				csongfile.1=csongfile.3
				dim mid,2
				//dim mid_pre,2
			}
			if(length(csongfile)>=2){
				exist csongfile.1
				if(((strsize=-1)|(feffecta=1))&(auto=1)){
					dim mid,1
					//dim mid_pre,1
					stat1=csongfile.0
					sdim csongfile,256,1
					csongfile.0=stat1
					feffect=1
				}
				if(((strsize=-1)|(feffecta=1))&(auto=0)){
					dim mid,1
					//dim mid_pre,1
					feffect=1
				}
			}
			exist csongfile.(max(length(csongfile)-1,0))
			if(((strsize=-1)|(peffecta=1))&(length(csongfile)>=4)&(auto=1)){
				stat1=csongfile.1
				sdim csongfile,256,1
				csongfile.0=stat1
				dim hPeakFX,1
				dim hPeakFX2,1
				dim hCompFX,1
				dim hVolFX2,1
				dim hBitCFX,1
				peffect=1
				oldpfilter=1
				if(anagainnum=0){
					anagain.0.0=0
					anagain.0.1=50
					anagainnum=1
					laserdelay1=0
					disableshuwa=1
				}else:if((anagainnum=1)&(anagain.0.1=0)){
					anagain.0.0=0
					anagain.0.1=50
					laserdelay1=0
					disableshuwa=1
				}
			}
			if(((peffecta=1)|(strsize=-1))&(auto=0)){
				if((length(csongfile)>=4)&(anagainnum=0)){
					anagain.0.0=0
					anagain.0.1=50
					anagainnum=1
					laserdelay1=0
					disableshuwa=1
				}else:if((length(csongfile)>=4)&(anagainnum=1)&(anagain.0.1=0)){
					anagain.0.0=0
					anagain.0.1=50
					laserdelay1=0
					disableshuwa=1
				}
				dim mid,2-(feffect=1)
				//dim mid_pre,2-(feffect=1)
				dim hPeakFX,2-(feffect=1)
				dim hPeakFX2,2-(feffect=1)
				dim hCompFX,2-(feffect=1)
				dim hVolFX2,1
				dim hBitCFX,2-(feffect=1)
				peffect=1
				oldpfilter=1
			}
			if((feffect=1)&(peffect=0)){
				dim mid,1
				//dim mid_pre,1
				dim hPeakFX,1
				dim hPeakFX2,1
				dim hCompFX,1
				dim hVolFX2,1
				dim hBitCFX,1
				peffect=1
				oldpfilter=1
				anagain.0.0=0
				anagain.0.1=50
				anagainnum=1
				laserdelay1=0
				disableshuwa=1
			}
			foreach mid
				mid.cnt=-1
				//mid_pre.cnt=-1
			loop
			foreach mid
				if(auto=0){
					if((length(csongfile)<=cnt)|((cnt>=2)&(peffect=1))){
						ccsongfile=csongfile.min(cnt\2,length(csongfile)-1)
					}else{
						ccsongfile=csongfile.cnt
					}
				}else{
					if((length(csongfile)<=cnt)|((cnt>=2)&(peffect=1))){
						ccsongfile=csongfile.min(1,length(csongfile)-1)
					}else:if((auto=1)&(length(csongfile)>=4)&(strsize!=-1)){
						ccsongfile=csongfile.(min(cnt,length(csongfile)-1))
					}else{
						ccsongfile=csongfile.(length(csongfile)-1)
					}
				}
				csongfile_exist=1
				exist ccsongfile
				if(strsize<=0):csongfile_exist=0
				//if((strsize<=0)&(strmid(csongfile.cnt,0,5)!="http:")):csongfile_exist=0
				if((strmid(ccsongfile,0,5)="http:")|(strmid(ccsongfile,0,6)="https:")){
					mid.cnt=BASS_StreamCreateURL(ccsongfile,0,0x20000,0,0,0)
					mlength=BASS_ChannelGetLength_ms(mid.cnt)
					if((peffect=1)&(auto=1)){
						hPeakFX.cnt=BASS_ChannelSetFX(mid.cnt,0x10013,2)
						hPeakFX2.cnt=BASS_ChannelSetFX(mid.cnt,0x10013,3)
						hBitCFX.cnt=BASS_VST_ChannelSetDSP(mid.cnt,dir_default+"\\lib\\bitc.dll",0,8)
						BASS_VST_SetParam_R hBitCFX.cnt,0,0.0f
						hCompFX.cnt=-1
						hVolFX2.cnt=-1
					}else:if((peffect=1)/*&(cnt>=2)*/){
						hPeakFX.cnt=BASS_ChannelSetFX(mid.cnt,0x10013,2)
						hPeakFX2.cnt=BASS_ChannelSetFX(mid.cnt,0x10013,3)
						hBitCFX.cnt=BASS_VST_ChannelSetDSP(mid.cnt,dir_default+"\\lib\\bitc.dll",0,8)
						BASS_VST_SetParam_R hBitCFX.cnt,0,0.0f
						hCompFX.cnt=-1
						hVolFX2.cnt=-1
					}
					csongfile_exist=1
				}else{
					/*
					mid_pre.cnt=BASS_StreamCreateFile(0,ccsongfile,0,0,0,0,0x20000)
					BASS_ChannelSetAttribute mid_pre.cnt,2,0.0f
					BASS_ChannelPlay mid_pre.cnt*/
					mdataptr=0
					exist ccsongfile
					if(strsize>0){
						if(cnt=0){
							sdim mdata0,strsize
							bload ccsongfile,mdata0
							mdataptr=varptr(mdata0)
						}else:if(cnt=1){
							sdim mdata1,strsize
							bload ccsongfile,mdata1
							mdataptr=varptr(mdata1)
						}else:if(cnt=2){
							sdim mdata2,strsize
							bload ccsongfile,mdata2
							mdataptr=varptr(mdata2)
						}else{
							sdim mdata3,strsize
							bload ccsongfile,mdata3
							mdataptr=varptr(mdata3)
						}
						mid.cnt=BASS_StreamCreateFile(1,mdataptr,0,0,strsize,0,0x20000)
					}
					if(cnt=0){
						mlength=BASS_ChannelGetLength_ms(mid.cnt)
					}else{
						BASS_ChannelSetLink mid.0,mid.cnt
						if(BASS_ErrorGetCode()!=0){
							mlinkfailed=mlinkfailed|1
						}
					}
					if((peffect=1)&(auto=1)){
						hPeakFX.cnt=BASS_ChannelSetFX(mid.cnt,0x10013,2)
						hPeakFX2.cnt=BASS_ChannelSetFX(mid.cnt,0x10013,3)
						hCompFX.cnt=-1
						hBitCFX.cnt=BASS_VST_ChannelSetDSP(mid.cnt,dir_default+"\\lib\\bitc.dll",0,8)
						BASS_VST_SetParam_R hBitCFX.cnt,0,0.0f
						hVolFX2.cnt=-1
					}else:if((peffect=1)/*&(cnt>=2)*/){
						hPeakFX.cnt=BASS_ChannelSetFX(mid.cnt,0x10013,2)
						hPeakFX2.cnt=BASS_ChannelSetFX(mid.cnt,0x10013,3)
						hBitCFX.cnt=BASS_VST_ChannelSetDSP(mid.cnt,dir_default+"\\lib\\bitc.dll",0,8)
						BASS_VST_SetParam_R hBitCFX.cnt,0,0.0f
						hCompFX.cnt=-1
						hVolFX2.cnt=-1
					}
				}
			loop
			continue
		}
		if(StartsWith(d.cnt, "ver=")){
			csongver=strmid(d.cnt,4,128)
			csongver_int=int(strmid(csongver,0,3))
			continue
		}
		if(StartsWith(d.cnt, "mvol=")){
			csongvol=int(strmid(d.cnt,5,5))*dirvol/100
			continue
		}
		if(StartsWith(d.cnt, "pfilterdelay=")){
			laserdelay1=int(strmid(d.cnt,13,16))
			if(laserdelay<0):laserdelay1=40
			if(laserdelay>160):laserdelay1=160
			continue
		}
		if(StartsWith(d.cnt, "v=")){
			cmovfile=strmid(d.cnt,2,128)
			_sjis_ cmovfile
			continue
		}
		if(StartsWith(d.cnt, "o=")){
			offset=int(strmid(d.cnt,2,64))+diroffset
			continue
		}
		if(StartsWith(d.cnt, "vo=")){
			voffset=int(strmid(d.cnt,3,64))
			continue
		}
		if(StartsWith(d.cnt, "total=")){
			csongtotal=int(strmid(d.cnt,6,64))
			continue
		}
		if(StartsWith(d.cnt, "t=")){
			if((int(double(strmid(d.cnt,2,64))*1000)>0)&(strmid(d.cnt,2,64)=replace(strmid(d.cnt,2,64),"-",""))){
				bpm=int(double(strmid(d.cnt,2,64))*1000)
				if(cnt3<0){
					bpml.bpmlnum.0=int(cbcnt)
				}else{
					bpml.bpmlnum.0=(cnt2+1)*UNIT_MEASURE*beatn/beatd/div.cnt3+int(cbcnt)
				}
				if(bpml.bpmlnum.0<0):bpml.bpmlnum.0=0
				bpml.bpmlnum.1=bpm
				bpmlnum++
			}
			continue
		}
		if(StartsWith(d.cnt, "to=")){
			csongoftbpm=int(double(strmid(d.cnt,3,16))*1000)
			if(csongoftbpm<1):csongoftbpm=0
			if(csongoftbpm>65535000):csongoftbpm=0
			continue
		}
		if(StartsWith(d.cnt, "beat=")){
			sdim beatstat,16,2
			stat1=strmid(d.cnt,5,33)
			split stat1,"/",beatstat
			if(length(beatstat)=2){
				if(cnt3<0){
					beatl.beatlnum.0=int(cbcnt)
				}else{
					beatl.beatlnum.0=(cnt2+1)*(UNIT_MEASURE*beatn/beatd)/div.cnt3+int(cbcnt)
				}
				beatl.beatlnum.1=int(beatstat.0)
				beatl.beatlnum.2=int(beatstat.1)
				if((beatl.beatlnum.1>0)&(beatl.beatlnum.2>0)){
					beatlnum++
					beatn=int(beatstat.0)
					beatd=int(beatstat.1)
				}
			}
			continue
		}
		if(StartsWith(d.cnt, "stop=")){
			if(adjmode!=1){
				if(cnt3<0){
					stp.stpnum.0=int(cbcnt)
				}else{
					stp.stpnum.0=(cnt2+1)*UNIT_MEASURE*beatn/beatd/div.cnt3+int(cbcnt)
				}
				if((stp.stpnum.0>=0)&(int(strmid(d.cnt,5,16))>0)){
					stp.stpnum.1=int(strmid(d.cnt,5,16))*625/12
					//stpsh+=stp.stpnum.1
					if(stpnum<=0){
						stpnum++
					}else:if(stp.(stpnum-1).0+stp.(stpnum-1).1<=stp.stpnum.0){
						stpnum++
					}
				}
			}
			continue
		}

		// 現在のmeasure値(カウント値)
		if(cnt3<0){
			cmeasure=int(cbcnt)
		}else:if(div.cnt3=0){
			cmeasure=int(cbcnt)
		}else{
			cmeasure=(cnt2+1)*UNIT_MEASURE*beatn/beatd/div.cnt3+int(cbcnt)
		}
		
		if(StartsWith(d.cnt, "tilt=")){
			if(cnt3<0){
				tilt.tiltnum.0=cbcnt+stpsh
			}else{
				tilt.tiltnum.0=(cnt2+1)*UNIT_MEASURE*beatn/beatd/div.cnt3+cbcnt
			}
			if(strmid(d.cnt,5,16)="normal"){
				tilt.tiltnum.1=0
			}else:if(strmid(d.cnt,5,16)="big"){
				tilt.tiltnum.1=1
			}else:if(strmid(d.cnt,5,16)="bigger"){
				tilt.tiltnum.1=1
			}else:if(strmid(d.cnt,5,16)="biggest"){
				tilt.tiltnum.1=2
			}else:if(strmid(d.cnt,5,16)="keep_normal"){
				tilt.tiltnum.1=3
			}else:if(strmid(d.cnt,5,16)="keep_bigger"){
				tilt.tiltnum.1=4
			}else:if(strmid(d.cnt,5,16)="keep_biggest"){
				tilt.tiltnum.1=5
			}else:if(strmid(d.cnt,5,16)="zero"){
				tilt.tiltnum.1=6
			}else:if(strmid(d.cnt,5,16)="keep"){
				tilt.tiltnum.1=4
			}else{
				// 傾きの数値指定(値の推移計算はGameSystemに移管済み)
				tilt.tiltnum.1=7
			}
			tiltp=tilt.tiltnum.1
			if((tilt.tiltnum.0!=0)|(tilt.tiltnum.1!=0)):tiltnum++
			continue
		}
		if(StartsWith(d.cnt, "center_split=")){
			anaranfl=2
			continue
		}
		if(StartsWith(d.cnt, "laserrange_l=")){
			anaran.anarannum.0=0^pturna
			if(cnt3<0){
				anaran.anarannum.1=int(cbcnt)
			}else{
				anaran.anarannum.1=(cnt2+1)*UNIT_MEASURE*beatn/beatd/div.cnt3+int(cbcnt)
			}
			if(strmid(d.cnt,13,2)="2x"){
				anaran.anarannum.2=2
			}else:anaran.anarannum.2=1
			anarannum++
			anaranfl=2
			continue
		}
		if(StartsWith(d.cnt, "laserrange_r=")){
			anaran.anarannum.0=1^pturna
			if(cnt3<0){
				anaran.anarannum.1=int(cbcnt)
			}else{
				anaran.anarannum.1=(cnt2+1)*UNIT_MEASURE*beatn/beatd/div.cnt3+int(cbcnt)
			}
			if(strmid(d.cnt,13,2)="2x"){
				anaran.anarannum.2=2
			}else:anaran.anarannum.2=1
			anarannum++
			anaranfl=2
			continue
		}
		if(StartsWith(d.cnt, "pfiltergain=")){
			if(cnt3<0){
				anagain.anagainnum.0=int(cbcnt)
			}else{
				anagain.anagainnum.0=(cnt2+1)*UNIT_MEASURE*beatn/beatd/div.cnt3+int(cbcnt)
			}
			if(((int(strmid(d.cnt,12,3))=0)&(oldpfilter=0))|((int(strmid(d.cnt,12,3))>0)&(int(strmid(d.cnt,12,3))<=100))){
				anagain.anagainnum.1=int(strmid(d.cnt,12,3))
				anagainnum++
			}
			continue
		}
		if(StartsWith(d.cnt, "chokkakuvol=")){
			if(cnt3<0){
				anvol.anvolnum.0=int(cbcnt)
			}else{
				anvol.anvolnum.0=(cnt2+1)*UNIT_MEASURE*beatn/beatd/div.cnt3+int(cbcnt)
			}
			if((int(strmid(d.cnt,12,3))>=0)&(int(strmid(d.cnt,12,3))<=100)){
				anvol.anvolnum.1=int(strmid(d.cnt,12,3))
				anvolnum++
			}
			continue
		}
		if(StartsWith(d.cnt, "chokkakuse=")){
			if(cnt3<0){
				anse.ansenum.0=int(cbcnt)
			}else{
				anse.ansenum.0=(cnt2+1)*UNIT_MEASURE*beatn/beatd/div.cnt3+int(cbcnt)
			}
			f=1
			switch strmid(d.cnt,11,64)
			case "down"
				anse.ansenum.1=1
				swbreak
			case "up"
				anse.ansenum.1=2
				swbreak
			case "swing"
				anse.ansenum.1=3
				swbreak
			case "mute"
				anse.ansenum.1=4
				swbreak
			default
				f=0
			swend
			if(f=1):ansenum++
			continue
		}
		stat1=replace(d.cnt,"\t"," ")
		if(strmid(stat1,0,11)="#define_fx "){
			fxdefbuf_fx+=stat1+"\n"
			continue
		}
		if(strmid(stat1,0,15)="#define_filter "){
			fxdefbuf_filter+=stat1+"\n"
			continue
		}
		if((strmid(d.cnt,7,1)!="|")|(d.cnt!=replace(d.cnt,"=",""))){
			continue
		}
		if(cnt3<0):continue
		if(div.cnt3=0):continue
		cnt2++ // カレント小節数/div(小節内)
	loop
	if(csongver=""){
		csongvol=csongvol*6/10
	}
	cmov=(cmovfile="")

	// layer名のパース
	parseLayerName

	// BPMが異常な場合は修正
	fixBPMErrors

	return

#deffunc parseLayerName /*private*/
	if(csonglayerstr!=""){
		sdim bgnamestat,0,1
		if(csongver_int>=166){
			split csonglayerstr,";",bgnamestat
		}else{
			split csonglayerstr,"/",bgnamestat
		}
		if(length(bgnamestat)=3){
			if(bgnamestat.2="2"):bgrotation=2
			if(bgnamestat.2="1"):bgrotation=1
			if(bgnamestat.2="0"):bgrotation=0
			bgname_l=bgnamestat.0
			bgspeed=int(bgnamestat.1)
		}else:if(length(bgnamestat)=2){
			bgname_l=bgnamestat.0
			bgspeed=int(bgnamestat.1)
		}else{
			bgname_l=csonglayerstr
			bgspeed=0
		}
	}
	return

#deffunc fixBPMErrors /*private*/
	// BPMの記述がない場合BPMを120にする
	if(bpmlnum=0){
		bpml.0.0=0
		bpml.0.1=120000
		bpmlnum=1
	}

	// BPMの上限を65535.000にする
	if(int(strmid(csongver,0,3))>=130){
		repeat bpmlnum
			bpml.cnt.1=min(bpml.cnt.1,65535000)
		loop
	}
	return

#deffunc parseKSHChartBody
	ddim rorp,1
	ddim ror_p,1
	cnt3=-1
	cnt2a=-1
	stat4=0
	stat4_2=0
	totalcombo=0
	mlinkfailed=0
	pturnlp=pturnl
	dim arfcnt,6
	dim np,6
	np=-1,-1,-1,-1,-1,-1
	ddim cbcnt,1
	beatn=4
	beatd=4
	t_finalnote=1

	// 各エフェクトが譜面に含まれるどうか
	// (含まれるエフェクトのみ使用するために調査)
	fl_Retr=0
	fl_Gate=0
	fl_Flan=0
	fl_Pitc=0
	fl_BitC=0
	fl_Phas=0
	fl_TStp=0
	fl_Echo=0
	fl_SiCh=0

	dim fxfl,2
	dim anagrcnt,2

	// 直後のノーツに適用されるキー音情報
	sdim nextKeySoundNamesLR, 256, 2
	nextKeySoundNamesLR = "", ""
	nextKeySoundVolumesLR = 100, 100

	_csongtitle=csongtitle
	if (lpeek(_csongtitle, 0) & 0x00FFFFFF) == 0xBFBBEF{
		DeleteUTF8BOM _csongtitle
	}

	repeat length(d)
		cnt2a++
		if(StartsWith(d.cnt, "//")){
			continue
		}
		if(d.cnt="--"){
			cnt3++ // カレント小節数
			if(cnt3>0):cbcnt+=UNIT_MEASURE*beatn/beatd
			cnt2=-1
			continue
		}
		if(StartsWith(d.cnt, "t=")){
			bpm=int(double(strmid(d.cnt,2,16))*1000)
			continue
		}
		if(StartsWith(d.cnt, "beat=")){
			sdim beatstat,16,2
			stat1=strmid(d.cnt,5,33)
			split stat1,"/",beatstat
			if(length(beatstat)=2){
				if((int(beatstat.0)>0)&(int(beatstat.1)>0)){
					beatn=int(beatstat.0)
					beatd=int(beatstat.1)
				}
			}
			continue
		}
		if(StartsWith(d.cnt, "chiprate=")){
			if(strmid(d.cnt,9,2)="1x"){
				chiprate=1
			}else:if(strmid(d.cnt,9,2)="2x"){
				chiprate=2
			}else:if(strmid(d.cnt,9,2)="3x"){
				chiprate=3
			}
			continue
		}
		if(StartsWith(d.cnt, "longrate=")){
			if(strmid(d.cnt,9,2)="1x"){
				longrate=1
			}else:if(strmid(d.cnt,9,2)="2x"){
				longrate=2
			}else:if(strmid(d.cnt,9,2)="3x"){
				longrate=3
			}
			continue
		}
		if(StartsWith(d.cnt, "laserrate=")){
			if(strmid(d.cnt,10,2)="1x"){
				laserrate=1
			}else:if(strmid(d.cnt,10,2)="2x"){
				laserrate=2
			}else:if(strmid(d.cnt,10,2)="3x"){
				laserrate=2
			}
			continue
		}
		if(StartsWith(d.cnt, "filtertype=")){
			if(cnt3<0){
				anafil.anafilnum.0=int(cbcnt)
			}else{
				anafil.anafilnum.0=(cnt2+1)*UNIT_MEASURE*beatn/beatd/div.cnt3+int(cbcnt)
			}
			f=1
			_cnt=cnt
			repeat userfilternum,userfxnum-userfilternum
				if(strmid(d._cnt,11,256)=userfilter_name.(cnt-(userfxnum-userfilternum))){
					anafil.anafilnum.1=100+cnt
					userfx_fl.cnt=1
					f=0
					break
				}
			loop
			if(f=1){
				if(strmid(d.cnt,11,4)="hpf1"){
					anafil.anafilnum.1=1
				}else:if(strmid(d.cnt,11,4)="hpf2"){
					anafil.anafilnum.1=2
				}else:if(strmid(d.cnt,11,4)="lpf1"){
					anafil.anafilnum.1=3
				}else:if(strmid(d.cnt,11,4)="lpf2"){
					anafil.anafilnum.1=4
				}else:if(strmid(d.cnt,11,4)="bitc"){
					anafil.anafilnum.1=5
				}else:if((feffect=1)&(strmid(d.cnt,11,7)="fx;bitc")){
					anafil.anafilnum.1=5
				}else:if((strmid(d.cnt,11,3)="fx;")|(strmid(d.cnt,11,3)="fx")){
					anafil.anafilnum.1=-1
				}else:if(strmid(d.cnt,11,4)="peak"){
					anafil.anafilnum.1=0
				}else{
					dialog "Error: Undefined filter (\""+strmid(d.cnt,11,256)+"\")"
					anafil.anafilnum.1=0
				}
			}
			anafilnum++
			continue
		}
		continuefl=0
		_cnt=cnt
		repeat 2
			if (startsWith(d._cnt, "fx-" + str_lr.cnt + "=")) {
				fx.fxnum.0=cnt
				if(cnt3<0){
					fx.fxnum.1=cbcnt
				}else{
					fx.fxnum.1=(cnt2+1)*UNIT_MEASURE*beatn/beatd/div.cnt3+cbcnt
				}
				stat1=strmid(d._cnt,5,64)
				if(stat1=""){
					fx.fxnum.2=0
				}else{
					sdim fxsplitstat,1
					split stat1,";",fxsplitstat
					f=1
					repeat userfxnum
						if(fxsplitstat.0=userfx_name.cnt){
							fx.fxnum.2=100+cnt
							userfx_fl.cnt=1
							if(userfx_params.cnt.0=FXDEF_FXTYPE_RETR){
								if(length(fxsplitstat)<=1){
									fx.fxnum.3=8
								}else:fx.fxnum.3=max(min(int(fxsplitstat.1),192),1)
							}else:if(userfx_params.cnt.0=FXDEF_FXTYPE_GATE){
								if(length(fxsplitstat)<=1){
									fx.fxnum.3=4
								}else:fx.fxnum.3=max(min(int(fxsplitstat.1),192),1)
							}else:if(userfx_params.cnt.0=FXDEF_FXTYPE_BITC){
								if(length(fxsplitstat)<=1){
									fx.fxnum.3=5
								}else:fx.fxnum.3=max(min(int(fxsplitstat.1),64),1)
							}else:if(userfx_params.cnt.0=FXDEF_FXTYPE_WOBB){
								if(length(fxsplitstat)<=1){
									fx.fxnum.3=12
								}else:fx.fxnum.3=max(min(int(fxsplitstat.1),192),1)
							}else:if(userfx_params.cnt.0=FXDEF_FXTYPE_TSTP){
								if(length(fxsplitstat)<=1){
									fx.fxnum.3=50
								}else:fx.fxnum.3=max(min(int(fxsplitstat.1),100),1)
							}else:if(userfx_params.cnt.0=FXDEF_FXTYPE_ECHO){
								if(length(fxsplitstat)<=1){
									fx.fxnum.3=4
									fx.fxnum.4=60
								}else:if(length(fxsplitstat)<=2){
									fx.fxnum.3=max(min(int(fxsplitstat.1),192),1)
									fx.fxnum.4=60
								}else{
									fx.fxnum.3=max(min(int(fxsplitstat.1),192),1)
									fx.fxnum.4=max(min(int(fxsplitstat.2),100),0)
								}
							}else:if(userfx_params.cnt.0=FXDEF_FXTYPE_PITC){
								if(length(fxsplitstat)<=1){
									fx.fxnum.3=12
								}else:fx.fxnum.3=max(min(int(fxsplitstat.1),48),-48)
							}
							f=0
							break
						}
					loop
					if(f=1){
						switch fxsplitstat.0
						case "Retrigger":
							if(length(fxsplitstat)<=1){
								fx.fxnum.3=8
							}else:fx.fxnum.3=max(min(int(fxsplitstat.1),192),1)
							if(fx.fxnum.3=12){
								fx.fxnum.2=FX_RE12
							}else:if(fx.fxnum.3=16){
								fx.fxnum.2=FX_RE16
							}else:if(fx.fxnum.3=24){
								fx.fxnum.2=FX_RE24
							}else:if(fx.fxnum.3=32){
								fx.fxnum.2=FX_RE32
							}else{
								fx.fxnum.2=FX_RE8
							}
							fl_Retr=1
							swbreak
						case "Gate":
							if(length(fxsplitstat)<=1){
								fx.fxnum.3=4
							}else:fx.fxnum.3=max(min(int(fxsplitstat.1),192),1)
							if(fx.fxnum.3=8){
								fx.fxnum.2=FX_GA8
							}else:if(fx.fxnum.3=12){
								fx.fxnum.2=FX_GA12
							}else:if(fx.fxnum.3=16){
								fx.fxnum.2=FX_GA16
							}else:if(fx.fxnum.3=24){
								fx.fxnum.2=FX_GA24
							}else:if(fx.fxnum.3=32){
								fx.fxnum.2=FX_GA32
							}else{
								fx.fxnum.2=FX_GA4
							}
							fl_Gate=1
							swbreak
						case "Flanger":
							fx.fxnum.2=FX_FLAN
							fl_Flan=1
							swbreak
						case "PitchShift":
							if(length(fxsplitstat)<=1){
								fx.fxnum.3=12
							}else:fx.fxnum.3=max(min(int(fxsplitstat.1),48),-48)
							fx.fxnum.2=FX_PITC
							fl_Pitc=1
							swbreak
						case "Phaser":
							fx.fxnum.2=FX_PHAS
							fl_Phas=1
							swbreak
						case "BitCrusher":
							if(length(fxsplitstat)<=1){
								fx.fxnum.3=5
							}else:fx.fxnum.3=max(min(int(fxsplitstat.1),64),0)
							fx.fxnum.2=FX_BITC
							fl_BitC=1
							swbreak
						case "Wobble":
							if(length(fxsplitstat)<=1){
								fx.fxnum.3=12
							}else:fx.fxnum.3=max(min(int(fxsplitstat.1),192),1)
							fx.fxnum.2=FX_WO12
							fl_Gate=1
							swbreak
						case "TapeStop":
							if(length(fxsplitstat)<=1){
								fx.fxnum.3=50
							}else:fx.fxnum.3=max(min(int(fxsplitstat.1),100),0)
							fx.fxnum.2=FX_TSTP
							fl_TStp=1
							swbreak
						case "Echo":
							if(length(fxsplitstat)<=1){
								fx.fxnum.3=4
								fx.fxnum.4=60
							}else:if(length(fxsplitstat)<=2){
								fx.fxnum.3=max(min(int(fxsplitstat.1),192),1)
								fx.fxnum.4=60
							}else{
								fx.fxnum.3=max(min(int(fxsplitstat.1),192),1)
								fx.fxnum.4=max(min(int(fxsplitstat.2),100),0)
							}
							fx.fxnum.2=FX_EC4
							fl_Echo=1
							swbreak
						case "SideChain":
							fx.fxnum.2=FX_SICH
							fl_SiCh=1
							swbreak
						case "":
							fx.fxnum.2=0
							swbreak
						default:
							fx.fxnum.2=0
							dialog "Error: Undefined fx (\""+fxsplitstat.0+"\")"
						swend
					}
				}
				fxfl.cnt=1
				fxnum++
				continuefl=1
			}
		loop
		if(continuefl=1):continue
		if(StartsWith(d.cnt, "fx-l_param1=")){
			fxparams.fxparamsnum.0=0
			if(cnt3<0){
				fxparams.fxparamsnum.1=cbcnt
			}else{
				fxparams.fxparamsnum.1=(cnt2+1)*UNIT_MEASURE*beatn/beatd/div.cnt3+cbcnt
			}
			fxparams.fxparamsnum.2=int(strmid(d.cnt,12,8))
			fxparamsnum++
			continue
		}
		if(StartsWith(d.cnt, "fx-r_param1=")){
			fxparams.fxparamsnum.0=1
			if(cnt3<0){
				fxparams.fxparamsnum.1=cbcnt
			}else{
				fxparams.fxparamsnum.1=(cnt2+1)*UNIT_MEASURE*beatn/beatd/div.cnt3+cbcnt
			}
			fxparams.fxparamsnum.2=int(strmid(d.cnt,12,8))
			fxparamsnum++
			continue
		}
		if(StartsWith(d.cnt, "fx-l_se=")|StartsWith(d.cnt, "fx-r_se=")){
			_stat1=strmid(d.cnt,8,256)
			sdim splitstat,1
			split _stat1,";",splitstat
			_stat1 = splitstat.0
			if(length(splitstat)=1){
				_stat3=100
			}else{
				_stat3=min(max(int(splitstat.1),0),100)
			}
			loadKeySoundToLibrary _stat1, getpath(cnotesfile,32), csongver_int
			if(StartsWith(d.cnt, "fx-l_se=")){
				nextKeySoundNamesLR.0=_stat1
				nextKeySoundVolumesLR.0=_stat3
			}
			if(StartsWith(d.cnt, "fx-r_se=")){
				nextKeySoundNamesLR.1=_stat1
				nextKeySoundVolumesLR.1=_stat3
			}
			continue
		}
		if((StartsWith(d.cnt, "fx:")&(instr(d.cnt,3,"="))!=-1)){
			if(cnt3<0){
				userchprm.userchprmnum.0=c2tf(cbcnt)
			}else{
				userchprm.userchprmnum.0=c2tf((cnt2+1)*UNIT_MEASURE*beatn/beatd/div.cnt3+cbcnt)
			}
			sdim fxsplit_stat,1
			_stat1=strmid(d.cnt,3,instr(d.cnt,3,"="))
			_stat4=strmid(d.cnt,4+instr(d.cnt,3,"="),256)
			if(instr(_stat1,0,":")!=-1){
				_stat2=strmid(_stat1,0,instr(_stat1,0,":"))
				_stat3=0
				f=1
				repeat userfxnum-userfilternum
					// 一致するユーザー定義FXを探索
					if(_stat2=userfx_name.cnt){
						userchprm.userchprmnum.1=double(cnt)
						_stat3=int(userfx_params.cnt.0)
						f=0
						break
					}
				loop
				if(f=1){
					dialog "Error: Undefined fx (\""+_stat2+"\")"
				}else:if(_stat3=FXDEF_FXTYPE_AUDI){
					dialog "Error: Cannot change \"SwitchAudio\" value"
				}else{
					f=1
					_stat1=strmid(_stat1,instr(_stat1,0,":")+1,256)
					// 一致するパラメータ名があるか調べる
					repeat fxdef_prmnum._stat3,1
						if(_stat1=fxdef_name.cnt._stat3){
							userchprm.userchprmnum.2=double(cnt)
							if(instr(_stat4,0,">")=-1){
								userchprm.userchprmnum.3=fxdef_str2param(_stat4,fxdef_type.cnt._stat3)
								userchprm.userchprmnum.4=fxdef_str2param(_stat4,fxdef_type.cnt._stat3)
							}else{
								userchprm.userchprmnum.3=fxdef_str2param(strmid(_stat4,0,instr(_stat4,0,">")),fxdef_type.cnt._stat3)
								userchprm.userchprmnum.4=fxdef_str2param(strmid(_stat4,instr(_stat4,0,">")+1,256),fxdef_type.cnt._stat3)
							}
							userfx_fl.(int(userchprm.userchprmnum.1))=1
							userchprmnum++
							f=0
							break
						}
					loop
					if(f=1):dialog "Error: Unknown paramater (\""+_stat1+"\")"
				}
			}
			continue
		}
		if((StartsWith(d.cnt, "filter:")&(instr(d.cnt,7,"="))!=-1)){
			if(cnt3<0){
				userchprm.userchprmnum.0=c2tf(cbcnt)
			}else{
				userchprm.userchprmnum.0=c2tf((cnt2+1)*UNIT_MEASURE*beatn/beatd/div.cnt3+cbcnt)
			}
			_stat1=strmid(d.cnt,7,instr(d.cnt,7,"="))
			_stat4=strmid(d.cnt,8+instr(d.cnt,7,"="),256)
			if(instr(_stat1,0,":")!=-1){
				_stat2=strmid(_stat1,0,instr(_stat1,0,":"))
				_stat3=0
				f=1
				repeat userfilternum
					// 一致するユーザー定義FXを探索
					if(_stat2=userfilter_name.cnt){
						userchprm.userchprmnum.1=double(cnt+userfxnum-userfilternum)
						_stat3=int(userfx_params.(cnt+userfxnum-userfilternum).0)
						f=0
						break
					}
				loop
				if(f=1){
					dialog "Error: Undefined filter (\""+_stat2+"\")"
				}else:if(_stat3=FXDEF_FXTYPE_AUDI){
					dialog "Error: \"SwitchAudio\" value cannot be changed"
				}else{
					f=1
					_stat1=strmid(_stat1,instr(_stat1,0,":")+1,256)
					// 一致するパラメータ名があるか調べる
					repeat fxdef_prmnum._stat3,1
						if(_stat1=fxdef_name.cnt._stat3){
							userchprm.userchprmnum.2=double(cnt)
							if(instr(_stat4,0,">")=-1){
								if(instr(_stat4,1,"-")=-1){
									userchprm.userchprmnum.3=fxdef_str2param(_stat4,fxdef_type.cnt._stat3)
									userchprm.userchprmnum.4=fxdef_str2param(_stat4,fxdef_type.cnt._stat3)
									userchprm.userchprmnum.5=fxdef_str2param(_stat4,fxdef_type.cnt._stat3)
								}else{
									userchprm.userchprmnum.3=fxdef_str2param(strmid(_stat4,0,instr(_stat4,1,"-")+1),fxdef_type.cnt.(_stat3))
									userchprm.userchprmnum.4=fxdef_str2param(strmid(_stat4,0,instr(_stat4,1,"-")+1),fxdef_type.cnt.(_stat3))
									userchprm.userchprmnum.5=fxdef_str2param(strmid(_stat4,instr(_stat4,1,"-")+2,256),fxdef_type.cnt.(_stat3))
								}
							}else{
								if(instr(_stat4,instr(_stat4,0,">")+2,"-")=-1){
									userchprm.userchprmnum.3=fxdef_str2param(strmid(_stat4,0,instr(_stat4,0,">")),fxdef_type.cnt.(_stat3))
									userchprm.userchprmnum.4=fxdef_str2param(strmid(_stat4,instr(_stat4,0,">")+1,256),fxdef_type.cnt.(_stat3))
									userchprm.userchprmnum.5=fxdef_str2param(strmid(_stat4,instr(_stat4,0,">")+1,256),fxdef_type.cnt.(_stat3))
								}else{
									userchprm.userchprmnum.3=fxdef_str2param(strmid(_stat4,0,instr(_stat4,0,">")),fxdef_type.cnt.(_stat3))
									userchprm.userchprmnum.4=fxdef_str2param(strmid(_stat4,instr(_stat4,0,">")+1,instr(_stat4,instr(_stat4,0,">")+2,"-")+1),fxdef_type.cnt.(_stat3))
									userchprm.userchprmnum.5=fxdef_str2param(strmid(_stat4,instr(_stat4,instr(_stat4,0,">")+2,"-")+instr(_stat4,0,">")+2+1,256),fxdef_type.cnt.(_stat3))
								}
							}
							userfx_fl.(int(userchprm.userchprmnum.1))=1
							userchprmnum++
							f=0
							break
						}
					loop
					if(f=1):dialog "Error: Unknown paramater (\""+_stat1+"\")"
				}
			}
			continue
		}
		if((strmid(d.cnt,7,1)!="|")|(d.cnt!=replace(d.cnt,"=",""))){
			continue
		}
		if(cnt3<0){
			dialog lang.2.1/*"譜面データの始端には小節線(--)を入力する必要があります。"*/,1,lang.0.2
			endfl=1
			break
		}
		if(/*(d.cnt="--")|*/(div.cnt3=0)){
			continue
		}
		cnt2++ // カレント小節数/div(小節内)
		exc=0
		if(cnt2a>0){
			repeat
				if((cnt2a-cnt-1)<0){
					exc=-1
					break
				}
				if(strmid(d.(cnt2a-cnt-1),4,1)!="|"){
					exc++
					continue
				}
				break
			loop
		}
		// ショートオブジェクトのリストアップ
		repeat 4
			if(shortmode=3):break
			if(adjmode=1):break
			// short
			if(strmid(d.cnt2a,cnt,1)="1"){
				if(turn=1){
					note.notenum.0=3-cnt
				}else:if(turn=2){
					note.notenum.0=pturn.cnt
				}else{
					note.notenum.0=cnt
				}
				note.notenum.1=int(cbcnt)+cnt2*UNIT_MEASURE*beatn/beatd/div.cnt3
				if(note.notenum.1>=cmdline_from){
					note.notenum.2=0
					note.notenum.3=c2t(note.notenum.1)
					note.notenum.4=note.notenum.3
					note.notenum.5=-1
					note.notenum.7=chiprate
					if(np.cnt!=-1){
						note.(np.cnt).5=notenum
					}
					np.cnt=notenum
					note.notenum.6=0
					if(t_finalnote<note.notenum.4):t_finalnote=note.notenum.4
					if((coloring=1)&(div.cnt3!=0)){
						f=0
						if(cnt2=0){
							note.notenum.6=1
							f=1
						}
						if((f=0)&(div.cnt3>=2)){
							if((div.cnt3\2=0)&(cnt2\(div.cnt3/2)=0)){
								note.notenum.6=1
								f=1
							}
						}
						if((f=0)&(div.cnt3>=4)){
							if((div.cnt3\4=0)&(cnt2\(div.cnt3/4)=0)){
								note.notenum.6=1
								f=1
							}
						}
						if((f=0)&(div.cnt3>=8)){
							if((div.cnt3\8=0)&(cnt2\(div.cnt3/8)=0)){
								note.notenum.6=2
								f=1
							}
						}
						if((f=0)&(div.cnt3>=12)){
							if((div.cnt3\12=0)&(cnt2\(div.cnt3/12)=0)){
								note.notenum.6=3
								f=1
							}
						}
						if((f=0)&(div.cnt3>=16)){
							if((div.cnt3\16=0)&(cnt2\(div.cnt3/16)=0)){
								note.notenum.6=4
								f=1
							}
						}
						if((f=0)&(div.cnt3>=24)){
							if((div.cnt3\24=0)&(cnt2\(div.cnt3/24)=0)){
								note.notenum.6=5
								f=1
							}
						}
						if((f=0)&(div.cnt3>=32)){
							if((div.cnt3\32=0)&(cnt2\(div.cnt3/32)=0)){
								note.notenum.6=6
								f=1
							}
						}
						if((f=0)&(div.cnt3>=48)){
							if((div.cnt3\48=0)&(cnt2\(div.cnt3/48)=0)){
								note.notenum.6=7
								f=1
							}
						}
						if((f=0)&(div.cnt3>=64)){
							if((div.cnt3\64=0)&(cnt2\(div.cnt3/64)=0)){
								note.notenum.6=8
								f=1
							}
						}
					}
					notese.notenum=-1 // チップBTオブジェクトは効果音を鳴らさない
					notenum++
					if(shortmode!=mode_off){
						totalcombo++
						stat4+=6*chiprate
						stat4_2+=200*chiprate
					}
				}
				continue
			}
			// long
			lcnt=cnt
			if(bpm<256000){
				f1=(note.notenum.2<=UNIT_MEASURE*3/16)
				f2=UNIT_MEASURE_16
			}else{
				f1=(note.notenum.2<=UNIT_MEASURE*3/8)
				f2=UNIT_MEASURE_8
			}
			if(strmid(d.cnt2a,cnt,1)="2")&((strmid(d.(cnt2a-exc-1),cnt,1)!="2")|(exc=-1)){
				excd=0
				beatn2=beatn
				beatd2=beatd
				ddim lend,1
				lend=double(UNIT_MEASURE)*beatn2/beatd2/div.cnt3
				repeat
					if(cnt2a+cnt+1>=length(d)){
						break
					}
					if(d.(cnt2a+cnt+1)=""){
						continue
					}
					if(strmid(d.(cnt2a+cnt+1),0,2)="--"){
						excd++
						continue
					}
					if(StartsWith(d.(cnt2a+cnt+1), "beat=")){
						sdim beatstat,16,2
						stat1=strmid(d.(cnt2a+cnt+1),5,33)
						split stat1,"/",beatstat
						if(length(beatstat)=2){
							if((int(beatstat.0)>0)&(int(beatstat.1)>0)){
								beatn2=int(beatstat.0)
								beatd2=int(beatstat.1)
							}
						}
						continue
					}
					if(strmid(d.(cnt2a+cnt+1),4,1)!="|"){
						continue
					}
					if(strmid(d.(cnt2a+cnt+1),lcnt,1)="2"){
						if(div.(cnt3+excd)=0):break
						lend+=double(UNIT_MEASURE)*beatn2/beatd2/div.(cnt3+excd)
					}else{
						break
					}
				loop
				if(turn=1){
					note.notenum.0=3-cnt
				}else:if(turn=2){
					note.notenum.0=pturn.cnt
				}else{
					note.notenum.0=cnt
				}
				note.notenum.1=int(cbcnt)+cnt2*UNIT_MEASURE*beatn/beatd/div.cnt3
				if(note.notenum.1>=cmdline_from){
					note.notenum.2=int(lend)
					note.notenum.3=c2t(note.notenum.1)
					note.notenum.4=c2t(note.notenum.1+note.notenum.2)
					if(t_finalnote<note.notenum.4):t_finalnote=note.notenum.4
					if(shortmode!=1){
						if(bpm<256000){
							stat1=(note.notenum.2<=UNIT_MEASURE*3/16)
							stat2=UNIT_MEASURE_16
						}else{
							stat1=(note.notenum.2<=UNIT_MEASURE*3/8)
							stat2=UNIT_MEASURE_8
						}
						if(stat1=1){
							if(turn=1){
								shlj.shljnum.0=3-cnt
							}else:if(turn=2){
								shlj.shljnum.0=pturn.cnt
							}else{
								shlj.shljnum.0=cnt
							}
							shlj.shljnum.1=note.notenum.1
							shlj.shljnum.2=note.notenum.2
							if(bpm<256000){
								if(note.notenum.2>=UNIT_MEASURE_16*2){
									shlj.shljnum.1+=UNIT_MEASURE_16
									shlj.shljnum.2=UNIT_MEASURE_16
								}
							}else{
								if(note.notenum.2>=UNIT_MEASURE_8*2){
									shlj.shljnum.1+=UNIT_MEASURE_8
									shlj.shljnum.2=UNIT_MEASURE_8
								}
							}
							shlj.shljnum.4=c2t(shlj.shljnum.1)
							shlj.shljnum.5=c2t(shlj.shljnum.1+shlj.shljnum.2)
							shlj.shljnum.6=notenum
							shlj.shljnum.7=longrate
							if(shortmode!=mode_off){
								stat4+=longrate
								stat4_2+=50*longrate
							}
							shljnum++
							totalcombo++
						}else{
							for i,(note.notenum.1+stat2-1)/stat2*stat2+stat2,note.notenum.1+note.notenum.2-stat2,stat2
								if(turn=1){
									shlj.shljnum.0=3-cnt
								}else:if(turn=2){
									shlj.shljnum.0=pturn.cnt
								}else{
									shlj.shljnum.0=cnt
								}
								shlj.shljnum.1=i
								shlj.shljnum.2=0
								if(i>note.notenum.1+note.notenum.2-stat2*2){
									shlj.shljnum.2+=stat2*2
								}else{
									shlj.shljnum.2+=stat2
								}
								shlj.shljnum.4=c2t(shlj.shljnum.1)
								shlj.shljnum.5=c2t(shlj.shljnum.1+shlj.shljnum.2)
								shlj.shljnum.6=notenum
								shlj.shljnum.7=longrate
								if(shortmode!=mode_off){
									stat4+=longrate
									stat4_2+=50*longrate
								}
								shljnum++
								totalcombo++
							next
						}
					}
					note.notenum.5=-1
					if(np.cnt!=-1){
						note.(np.cnt).5=notenum
					}
					np.cnt=notenum
					notese.notenum=-1 // ロングBTオブジェクトは効果音を鳴らさない
					notenum++
				}
			}
		loop
		// ロングオブジェクトのリストアップ
		repeat 2
			if(longmode=3):break
			lcnt=cnt
			if(strmid(d.cnt2a,cnt+5,1)="2"){
				note.notenum.0 = 4 + (cnt ^ pturnl)
				note.notenum.1=int(cbcnt)+cnt2*UNIT_MEASURE*beatn/beatd/div.cnt3
				if(note.notenum.1>=cmdline_from){
					note.notenum.2=0
					note.notenum.3=c2t(note.notenum.1)
					note.notenum.4=note.notenum.3
					note.notenum.5=-1
					note.notenum.7=chiprate
					if(t_finalnote<note.notenum.4):t_finalnote=note.notenum.4
					if(np.(cnt+4)!=-1){
						note.(np.(cnt+4)).5=notenum
					}
					np.(cnt+4)=notenum
					notese.notenum=-1
					// チップFXオブジェクトは効果音があれば鳴らす
					if(nextKeySoundNamesLR.lcnt != "" & keySoundExistsInLibrary(nextKeySoundNamesLR.lcnt)){
						notese.notenum = notesejnum
						notesej.notesejnum.0 = notenum // キー音の元オブジェクト番号
						notesej.notesejnum.1 = 0 // キー音の判定(0/1)
						notesej.notesejnum.2 = getKeySoundFromLibrary(nextKeySoundNamesLR.lcnt) // 再生するKeySoundへのポインタ
						notesej.notesejnum.3 = nextKeySoundVolumesLR.lcnt // 再生音量(%)
						notesejnum++
					}
					notenum++
					if(longmode!=mode_off){
						stat4+=6*chiprate
						stat4_2+=200*chiprate
						totalcombo++
					}
				}
				continue
			}
			if(strmid(d.cnt2a,cnt+5,1)!="0")&((strmid(d.(cnt2a-exc-1),cnt+5,1)="0")|(strmid(d.(cnt2a-exc-1),cnt+5,1)="2")|(exc=-1)){
				excd=0
				beatn2=beatn
				beatd2=beatd
				ddim lend,1
				lend=double(UNIT_MEASURE)*beatn2/beatd2/div.cnt3
				repeat
					if(cnt2a+cnt+1>=length(d)){
						break
					}
					if(d.(cnt2a+cnt+1)=""){
						continue
					}
					if(strmid(d.(cnt2a+cnt+1),0,2)="--"){
						excd++
						continue
					}
					if(StartsWith(d.(cnt2a+cnt+1), "beat=")){
						sdim beatstat,16,2
						stat1=strmid(d.(cnt2a+cnt+1),5,33)
						split stat1,"/",beatstat
						if(length(beatstat)=2){
							if((int(beatstat.0)>0)&(int(beatstat.1)>0)){
								beatn2=int(beatstat.0)
								beatd2=int(beatstat.1)
							}
						}
						continue
					}
					if(strmid(d.(cnt2a+cnt+1),4,1)!="|"){
						continue
					}
					if((strmid(d.(cnt2a+cnt+1),lcnt+5,1)!="0")&(strmid(d.(cnt2a+cnt+1),lcnt+5,1)!="2")){
						if(div.(cnt3+excd)=0):break
						lend+=double(UNIT_MEASURE)*beatn2/beatd2/div.(cnt3+excd)
					}else{
						break
					}
				loop
				note.notenum.0 = 4 + (cnt ^ pturnl)
				note.notenum.1=int(cbcnt)+cnt2*UNIT_MEASURE*beatn/beatd/div.cnt3
				if(note.notenum.1>=cmdline_from){
					note.notenum.2=int(lend)
					note.notenum.3=c2t(note.notenum.1)
					note.notenum.4=c2t(note.notenum.1+note.notenum.2)
					if(t_finalnote<note.notenum.4):t_finalnote=note.notenum.4
					if(longmode!=1){
						if(bpm<256000){
							stat1=(note.notenum.2<=UNIT_MEASURE*3/16)
							stat2=UNIT_MEASURE_16
						}else{
							stat1=(note.notenum.2<=UNIT_MEASURE*3/8)
							stat2=UNIT_MEASURE_8
						}
						if(stat1=1){
							longj.longjnum.0 = (cnt ^ pturnl)
							longj.longjnum.1=note.notenum.1
							longj.longjnum.2=note.notenum.2
							if(bpm<256000){
								if(note.notenum.2>=UNIT_MEASURE*2/16){
									longj.longjnum.1+=UNIT_MEASURE_16
									longj.longjnum.2=UNIT_MEASURE_16
								}
							}else{
								if(note.notenum.2>=UNIT_MEASURE*2/8){
									longj.longjnum.1+=UNIT_MEASURE_8
									longj.longjnum.2=UNIT_MEASURE_8
								}
							}
							longj.longjnum.4=c2t(longj.longjnum.1)
							longj.longjnum.5=c2t(longj.longjnum.1+longj.longjnum.2)
							longj.longjnum.6=notenum
							longj.longjnum.7=longrate
							if(longmode!=mode_off){
								stat4+=longrate
								stat4_2+=50*longrate
							}
							longjnum++
							totalcombo++
						}else{
							for i,(note.notenum.1+stat2-1)/stat2*stat2+stat2,note.notenum.1+note.notenum.2-stat2,stat2
								longj.longjnum.0 = (cnt ^ pturnl)
								longj.longjnum.1 = i
								longj.longjnum.2 = 0
								if(i>note.notenum.1+note.notenum.2-stat2*2){
									longj.longjnum.2+=stat2*2
								}else{
									longj.longjnum.2+=stat2
								}
								longj.longjnum.4=c2t(longj.longjnum.1)
								longj.longjnum.5=c2t(longj.longjnum.1+longj.longjnum.2)
								longj.longjnum.6=notenum
								longj.longjnum.7=longrate
								if(longmode!=mode_off){
									stat4+=longrate
									stat4_2+=50*longrate
								}
								longjnum++
								totalcombo++
							next
						}
					}
					note.notenum.5=-1
					if(np.(cnt+4)!=-1){
						note.(np.(cnt+4)).5=notenum
					}
					np.(cnt+4)=notenum
					notese.notenum=-1 // ロングFXオブジェクトは効果音を鳴らさない
					notenum++
				}
			}
			if((strmid(d.cnt2a,cnt+5,1)!="0")&((strmid(d.(cnt2a-exc-1),cnt+5,1)!=strmid(d.cnt2a,cnt+5,1))|(exc=-1)|((csongver_int>=160)&(fxfl.cnt=1)))){
				excd=0
				beatn2=beatn
				beatd2=beatd
				ddim lend,1
				lend=double(UNIT_MEASURE)*beatn2/beatd2/div.cnt3
				stat2=strmid(d.cnt2a,cnt+5,1)
				repeat
					if(cnt2a+cnt+1>=length(d)){
						break
					}
					if(d.(cnt2a+cnt+1)=""){
						continue
					}
					if(strmid(d.(cnt2a+cnt+1),0,2)="--"){
						excd++
						continue
					}
					if(StartsWith(d.(cnt2a+cnt+1), "beat=")){
						sdim beatstat,16,2
						stat1=strmid(d.(cnt2a+cnt+1),5,33)
						split stat1,"/",beatstat
						if(length(beatstat)=2){
							if((int(beatstat.0)>0)&(int(beatstat.1)>0)){
								beatn2=int(beatstat.0)
								beatd2=int(beatstat.1)
							}
						}
						continue
					}
					if(strmid(d.(cnt2a+cnt+1),4,1)!="|"){
						continue
					}
					if(strmid(d.(cnt2a+cnt+1),lcnt+5,1)=stat2){
						if(div.(cnt3+excd)=0):break
						lend+=double(UNIT_MEASURE)*beatn2/beatd2/div.(cnt3+excd)
					}else{
						break
					}
				loop
				notefx.notefxnum.0 = 4 + (cnt ^ pturnl)
				notefx.notefxnum.1=int(cbcnt)+cnt2*UNIT_MEASURE*beatn/beatd/div.cnt3
				notefx.notefxnum.2=int(lend)
				notefx.notefxnum.3=c2t(notefx.notefxnum.1)
				notefx.notefxnum.4=c2t(notefx.notefxnum.1+notefx.notefxnum.2)
				if(csongver_int>=160){
					repeat fxnum
						if((fx.cnt.0=lcnt)&(fx.cnt.1=notefx.notefxnum.1)){
							notefx.notefxnum.5=fx.cnt.2
							notefx.notefxnum.6=fx.cnt.3
							notefx.notefxnum.7=fx.cnt.4
							break
						}
					loop
				}else{
					stat1=strmid(d.cnt2a,cnt+5,1)
					if(stat2="S"){
						notefx.notefxnum.5=1
						notefx.notefxnum.6=fx_div.(notefx.notefxnum.5)
						fl_Retr=1
					}else:if(stat2="V"){
						notefx.notefxnum.5=2
						notefx.notefxnum.6=fx_div.(notefx.notefxnum.5)
						fl_Retr=1
					}else:if(stat2="T"){
						notefx.notefxnum.5=3
						notefx.notefxnum.6=fx_div.(notefx.notefxnum.5)
						fl_Retr=1
					}else:if(stat2="W"){
						notefx.notefxnum.5=4
						notefx.notefxnum.6=fx_div.(notefx.notefxnum.5)
						fl_Retr=1
					}else:if(stat2="U"){
						notefx.notefxnum.5=5
						notefx.notefxnum.6=fx_div.(notefx.notefxnum.5)
						fl_Retr=1
					}else:if(stat2="G"){
						notefx.notefxnum.5=6
						notefx.notefxnum.6=fx_div.(notefx.notefxnum.5)
						fl_Gate=1
					}else:if(stat2="H"){
						notefx.notefxnum.5=7
						notefx.notefxnum.6=fx_div.(notefx.notefxnum.5)
						fl_Gate=1
					}else:if(stat2="K"){
						notefx.notefxnum.5=8
						notefx.notefxnum.6=fx_div.(notefx.notefxnum.5)
						fl_Gate=1
					}else:if(stat2="I"){
						notefx.notefxnum.5=9
						notefx.notefxnum.6=fx_div.(notefx.notefxnum.5)
						fl_Gate=1
					}else:if(stat2="L"){
						notefx.notefxnum.5=10
						notefx.notefxnum.6=fx_div.(notefx.notefxnum.5)
						fl_Gate=1
					}else:if(stat2="J"){
						notefx.notefxnum.5=11
						notefx.notefxnum.6=fx_div.(notefx.notefxnum.5)
						fl_Gate=1
					}else:if(stat2="F"){
						notefx.notefxnum.5=12
						fl_Flan=1
					}else:if(stat2="P"){
						notefx.notefxnum.5=13
						note.notenum.4=12
					}else:if(stat2="B"){
						notefx.notefxnum.5=14
						notefx.notefxnum.6=5
						repeat fxparamsnum
							if((fxparams.cnt.0=notefx.notefxnum.0-4)&(fxparams.cnt.1=notefx.notefxnum.1)){
								notefx.notefxnum.6=min(max(fxparams.cnt.2,0),64)
							}
						loop
						fl_BitC=1
					}else:if(stat2="Q"){
						notefx.notefxnum.5=15
						fl_Phas=1
					}else:if(stat2="X"){
						notefx.notefxnum.5=16
						notefx.notefxnum.6=fx_div.(notefx.notefxnum.5)
						fl_Gate=1
					}else:if(stat2="A"){
						notefx.notefxnum.5=17
						repeat fxparamsnum
							if((fxparams.cnt.0=notefx.notefxnum.0-4)&(fxparams.cnt.1=notefx.notefxnum.1)){
								notefx.notefxnum.6=min(max(fxparams.cnt.2,0),100)
							}
						loop
						fl_TStp=1
					}else:if(stat2="D"){
						notefx.notefxnum.5=19
						fl_SiCh=1
					}else{
						notefx.notefxnum.5=0
					}
				}
				notefxnum++
			}
			fxfl.cnt=0
		loop
		// アナログデバイスのリストアップ
		dim analogturnstat,2
		repeat 2
			if(analogmode=3):break
			if((strmid(d.cnt2a,cnt+8,1)!="-")&(strmid(d.cnt2a,cnt+8,1)!=":")){
				cnt0=cnt
				// アナログデバイスの開始地点かどうかを判定
				exc=0
				if(cnt2a=0){
					analog.analognum.5=1
					anagrcnt.cnt=max(anagrcnt.0,anagrcnt.1)+1
				}else{
					repeat
						if(cnt2a-cnt-1<0){
							analog.analognum.5=1
							anagrcnt.cnt=max(anagrcnt.0,anagrcnt.1)+1
							break
						}
						if(strmid(d.(cnt2a-cnt-1),cnt0+8,1)=":"){
							exc++
							continue
						}
						if(strmid(d.(cnt2a-cnt-1),4,1)!="|"){
							exc++
							continue
						}
						break
					loop
					if(cnt2a-exc-1>=0){
						if(strmid(d.(cnt2a-exc-1),cnt+8,1)="-"){
							analog.analognum.5=1
							anagrcnt.cnt=max(anagrcnt.0,anagrcnt.1)+1
						}
						if(cnt2a>1){
							exc2=0
							repeat
								if(strmid(d.(cnt2a-exc-cnt-1),4,1)!="|"){
									exc2++
									continue
								}
								break
							loop
						}
					}
				}
				// アナログデバイスの変化にかかる長さを確認
				excd=0
				stat3=0
				beatn2=beatn
				beatd2=beatd
				ddim lend,1
				lend=double(UNIT_MEASURE)*beatn2/beatd2/div.(cnt3+excd)
				repeat
					if(stat3=1){
						stat3=0
					}
					if(cnt2a+cnt+1>=length(d)){
						stat1=-1 // 異常
						break
					}
					if(strmid(d.(cnt2a+cnt+1),0,2)="--"){
						excd++
						continue
					}
					if(StartsWith(d.(cnt2a+cnt+1), "beat=")){
						sdim beatstat,16,2
						stat1=strmid(d.(cnt2a+cnt+1),5,33)
						split stat1,"/",beatstat
						if(length(beatstat)=2){
							if((int(beatstat.0)>0)&(int(beatstat.1)>0)){
								beatn2=int(beatstat.0)
								beatd2=int(beatstat.1)
							}
						}
						continue
					}
					if(strmid(d.(cnt2a+cnt+1),4,1)!="|"){
						continue
					}
					if(div.(cnt3+excd)=0){
						break
					}
					if(strmid(d.(cnt2a+cnt+1),cnt0+8,1)!=":"){
						stat1=a2p(strmid(d.(cnt2a+cnt+1),cnt0+8,1))
						break
					}
					lend+=double(UNIT_MEASURE)*beatn2/beatd2/div.(cnt3+excd)
				loop
				// 異常がなければリストに追加
				if(stat1!=-1){
					// 対象のアナログデバイス(L:0,R:1)
					analog.analognum.0 = cnt ^ pturna
					analog.analognum.1 = int(cbcnt) + cnt2 * UNIT_MEASURE * beatn / beatd / div.cnt3 // 変化の始点カウント値
					if(analog.analognum.1>=cmdline_from){
						analog.analognum.2=int(lend) // 変化にかかる時間
						analog.analognum.6=c2t(analog.analognum.1) // 変化の始点t
						analog.analognum.7=c2t(analog.analognum.1+analog.analognum.2) // 変化の終点t
						if(t_finalnote<analog.analognum.7):t_finalnote=analog.analognum.7
						if((analog.analognum.5=1)&(anaendstat.cnt!=-1)){
							analog.(anaendstat.cnt).8=1
						}
						analog.analognum.9=-1
						if(anaendstat.cnt>=0):analognext.(anaendstat.cnt)=analognum
						analognext.analognum=-1
						analogprev.analognum=anaendstat.cnt
						anaendstat.cnt=analognum
						analog.analognum.3=a2p(strmid(d.cnt2a,cnt+8,1)) // 変化の初期値
						analog.analognum.4=stat1 // 変化の目標値
						if (pturna) {
							analog.analognum.3=50-analog.analognum.3
							analog.analognum.4=50-analog.analognum.4
						}
						if((analog.analognum.5=0)&(analogturnstat.cnt!=abs(analog.analognum.4-analog.analognum.3))){
							analogturn.cnt.(analogturnnum.cnt)=analog.analognum.6
							analogturnnum.cnt++
						}
						analogturnstat.cnt=abs(analog.analognum.4-analog.analognum.3)
						analoggr.analognum=anagrcnt.cnt // アナログデバイスのまとまりの番号
						analoggrmax.cnt=anagrcnt.cnt
						if(analogmode!=mode_off){
							if(bpm<256000){
								stat1=UNIT_MEASURE_16
							}else{
								stat1=UNIT_MEASURE_8
							}
							if((analog.analognum.2>UNIT_MEASURE_32)|(analog.analognum.3=analog.analognum.4)){
								for i,(analog.analognum.1+stat1-1)/stat1*stat1/*+analog.analognum.5*stat1*/,analog.analognum.1+analog.analognum.2,stat1
									analogj.analogjnum.0 = cnt ^ pturna
									analogj.analogjnum.1 = i
									analogj.analogjnum.3 = max(laserrate, 1)
									analogjnum++
									if(analogmode!=mode_off){
										stat4+=laserrate
										stat4_2+=50*laserrate
									}
								next
							}else{
								analoganj.analoganjnum.0 = cnt ^ pturna
								analoganj.analoganjnum.1 = analognum
								analoganj.analoganjnum.3 = analog.analognum.4
								analoganj.analoganjnum.4 = 0
								analoganj.analoganjnum.5 = max(laserrate, 1)
								analoganjnum++
								if(analogmode!=mode_off){
									stat4+=6*laserrate
									stat4_2+=200*laserrate
								}
							}
						}
						analognum++
					}
				}
			}
		loop
		if(strmid(d.cnt2a,10,1)="@"){
			// 画面回転のリストアップ
			f=1
			if(strmid(d.cnt2a,11,1)="("){
				spin.spinnum.0=0 // 時計回り回転
			}else:if(strmid(d.cnt2a,11,1)=")"){
				spin.spinnum.0=1 // 反時計回り
			}else:if(strmid(d.cnt2a,11,1)="<"){
				spin.spinnum.0=2 // 時計回り半回転
			}else:if(strmid(d.cnt2a,11,1)=">"){
				spin.spinnum.0=3 // 反時計回り半回転
			}else:f=0
			if(f=1){
				spin.spinnum.0 = spin.spinnum.0 / 2 * 2 + (spin.spinnum.0 - spin.spinnum.0 / 2 * 2) ^ pturna
				spin.spinnum.1 = int(cbcnt) + cnt2 * UNIT_MEASURE * beatn / beatd / div.cnt3 //位置
				spin.spinnum.2 = int(double(strmid(d.cnt2a, 12, 32)) * 625 / 12 * 145 / 100) //長さ(c)
				spinnum++
			}
		}
		if(strmid(d.cnt2a,10,1)="S"){
			// ばねエフェクトのリストアップ
			f=1
			if(strmid(d.cnt2a,11,1)="<"){
				spr.sprnum.0=0 // 左向き
			}else:if(strmid(d.cnt2a,11,1)=">"){
				spr.sprnum.0=1 // 右向き
			}else:f=0
			if(f=1){
				stat1=strmid(d.cnt2a,12,64)
				sdim splitstat,64,1
				split stat1,";",splitstat
				spr.sprnum.0 = spr.sprnum.0 / 2 * 2 + (spr.sprnum.0 - spr.sprnum.0 / 2 * 2) ^ pturna
				spr.sprnum.1=int(cbcnt)+cnt2*UNIT_MEASURE*beatn/beatd/div.cnt3 //位置
				spr.sprnum.2=int(double(splitstat.0)*625/12) //長さ(c)
				spr.sprnum.3=250 //揺れ幅
				if(length(splitstat)>=2):spr.sprnum.3=max(int(splitstat.1),0)
				spr.sprnum.4=3 //回数 (片道+1 往復+2)
				if(length(splitstat)>=3):spr.sprnum.4=max(int(splitstat.2),0)
				spr.sprnum.5=2 //減衰の有無 (0:なし 1:あり(遅) 2:あり)
				if(spr.sprnum.4>=0){
					if(length(splitstat)>=4):spr.sprnum.5=min(max(int(splitstat.3),0),2)
					sprnum++
				}
			}
		}
		pturnlp=pturnl
		nextKeySoundNamesLR = "", ""
		nextKeySoundVolumesLR = 100, 100
	loop
	repeat 2
		if(anaendstat.cnt!=-1):analog.(anaendstat.cnt).8=1
	loop
	totalcombo+=analoganjnum+analogjnum

	return

#deffunc prepareReferenceBPMsForHiSpeed
	// 最大BPM値を調べる
	maxbpm=1
	maxbpm_ir=1
	repeat bpmlnum
		if(maxbpm<bpml.cnt.1):maxbpm=min(bpml.cnt.1,65535000)
		if(maxbpm_ir<bpml.cnt.1):maxbpm_ir=bpml.cnt.1
	loop

	// 最小BPM値を調べる(IR用)
	minbpm_ir=bpml.0.1
	repeat bpmlnum-1,1
		if(minbpm_ir>bpml.cnt.1):minbpm_ir=bpml.cnt.1
	loop

	// 平均BPM値を調べる
	if(beatlnum=0){
		beatl.0.0=0
		beatl.0.1=4
		beatl.0.2=4
		beatlnum=1
	}
	repeat bpmlnum
		bpml.cnt.2=c2t(bpml.cnt.0)
	loop
	ddim avestat,1
	avebpm=min(bpml.0.1,65535000)
	if(bpmlnum>1){
		stat1=c2t(b2c(divnum))
		repeat bpmlnum
			if(cnt<bpmlnum-1){
				avestat+=double(min(bpml.cnt.1,65535000))*(bpml.(cnt+1).2-bpml.cnt.2)
			}else{
				avestat+=double(min(bpml.cnt.1,65535000))*(stat1-bpml.cnt.2)
			}
		loop
		avestat/=max(stat1,1)
		avebpm=max(int(avestat),1)
	}
	
	// 最頻BPM値を調べる
	dim oftbpmstat,65535
	oftbpm=1
	oftstat=0
	repeat bpmlnum
		if(cnt<bpmlnum-1){
			oftbpmstat.(min(max(bpml.cnt.1/1000,1),65535)-1)+=bpml.(cnt+1).0-bpml.cnt.0
		}else{
			oftbpmstat.(min(max(bpml.cnt.1/1000,1),65535)-1)+=b2c(divnum)-bpml.cnt.0
		}
		if((oftstat<oftbpmstat.(min(max(bpml.cnt.1/1000,1),65535)-1))|((oftstat=oftbpmstat.(min(max(bpml.cnt.1/1000,1),65535)-1))&(min(max(bpml.cnt.1/1000,1),65535)>oftbpm))){
			oftstat=oftbpmstat.(min(max(bpml.cnt.1/1000,1),65535)-1)
			oftbpm=min(max(bpml.cnt.1/1000,1),65535)
		}
	loop
	oftbpm*=1000
	if((csongoftbpm>0)&(csongoftbpm>=minbpm)&(csongoftbpm<=maxbpm)):oftbpm=csongoftbpm
	dim oftbpmstat,0
	return